\section{Broadcast}
Esempio. Broadcast: flooding protocol.
Un nodo vuole trasmettere a tutti gli altri un'informazione I.
Restrizioni:
 - unique initiator: per definizione del problema
 - G connesso: per definizione, altrimenti alcuni nodi resterebbero escluisi
 - Bidirectional links
 - Total reliability

\begin{verbatim}
S = {INITIATOR, SLEEPING, DONE}

INITIATOR
spontaneously
  send(I) to N(x)
  become(DONE)  # Transitiamo allo stato DONE
receiving(I)
  nil
  # In futuro ometteremo le azioni nil, se non specificate si evitano
  
SLEEPING
receiving(I)
  send(I) to N(x) - {sender}  # Sender è il nodo da cui ho ricevuto il messaggio
  become(DONE)  # Transitiamo allo stato DONE
\end{verbatim}

Oss. 1: lo stato DONE costituisce una terminazione locale, non esiste una terminazione globale.
Oss. 2: nessuna entità conosce quando l'intero processo termina (termination detection problem).

Terminazione? assicurata dalle restrizioni di connessione totale e affidabilità totale. Non abbiamo vincoli di direzionalità.
In un grafo totalmente connesso troveremo sempre un cammino dall'inizializzatore ad ogni altro nodo.

Costo del flooding.
Convenzione. n numero di nodi. m numero di link.

Tip. Per calcolare il costo temporale cerca relazioni tra quello che vuoi contare e quantità già note.
Da tenere in considerazione sono il numero di messaggi per arco, il numero 

Costo? su ogni arco incidono due nodi, ogni nodo trasmette I una sola volta; l'arco vede al massimo 2 messaggi.
\leq 2 messaggi per link. total num of messages <= 2m \in O(m).

TODO

Con l'ottimizzazione (non reinviare I a chi ce l'ha mandato) diventa: |N(s)| + sum_{x \neq s} (|N(x)|-1) = sum_{x} |N(x)| - sum_{x \neq s} 1 = 2m - (n-1).

Def. Distanza d(a, b). Numero minimo di archi tra tutti i percorsi tra a e b.
Def. Raggio o Eccentricità r(a). Massima distanza di un nodo a da tutti gli altri.
Def. Diametro di un grafo D(G). Massima eccentricità tra tutti i nodi di G.

Ideal time. In ogni istance ogni vicino riceve un messaggio.

r(initiator) = max_y{d(initiator, y)} \forall y \in E
Nel caso generale non conosciamo quale sia l'iniziatore. Il caso peggiore è il peggiore iniziatore per ogni possibile esecuzione.
Max_{(x, y)}{d(x, y)} = Max{r(x)} = D(G) for any pair (x, y) \in E x E

num of time units <= D(G) <= n-1 \in O(n) TODO riscrivi le time units con Time(Flooding(G)
Res. Il caso peggiore è quelo in cui il grafo è una catena (nodi srotolati e messi in fila).

In caso di casual time complexity il costo peggiore rimane n-1.
Anche se un grafo non è una catena, la propagazione dei messaggi sugli altri cammini potrebbe essere così lenta che la propagazione più
veloce è quella lungo il diametro.

Lower bound.
Si possono usare meno di n-1 time units? no, altrimenti salteremmo qualche nodo sul diametro del grafo.

Però\dots possiamo fare meglio in termini di numero di messaggi?
Intuzione. Dalla formulazione del problema, ogni entità deve conoscere I. Escluso l'inizializzatore rimangono n-1 entry che non conoscono I.
Almeno n-1 messaggi devono essere mandati.
Message(Broadcast(G)) >= n-1 \in \Omega(n)

Considerazione. Ogni messaggio deve passare almeno una volta su ogni arco, altrimenti alcune porzioni del grafo non potrebbero
ricevere I. Richiedere se l'altro nodo non ha il messaggio farebbe comunque spendere più di un messaggio per arco.

Possiamo migliorare il LB per il problema: Message(Brodadcast(G)) >= m \in \Omega(m)

Ricorda. Stiamo cercando di chiudere il gap tra LB del PROBLEMA e LB dell'ALGORITMO di flooding.
Message(Broadcast(G)) >= m
Message(Flooding(G)) = 2m - n + 1 (dalla scorsa lezione)
Message(Flooding(G)) >= Messsage(Broadcast(G))

Possiamo fare di meglio? Il gap che cerchiamo di chiudere è "grande": 2m - n + 1 - m = m - n + 1

Restrizioni.
Se applichiamo restrizioni al problema, si può fare di meglio.

Restrizione 1. Albero.
Assumendo G è un albero T. m = n-1 (ogni nodo ha un arco padre a parte la radice).

Message(Flooding(T)) = 2m - n - 1 = 2(n-1) - n - 1 = n - 1 = m

Gli algoritmi di flooding sono complessità ottimale, in termini di messaggi inviati, per gli alberi.

Restrizione 2. Grafo completo.
Aka, ogni nodo è connesso con tutti gli altri.
In grafi completi: m = n(n-1)/2. Vedi combinatoria o ragionamento intuitivo.

Message(Flooding(G)) \in \theta(n^2)
Message(SimpleBroadcast(G)) = n-1. Init manda a tutti i suoi vicini.
Time(SimpleBroadcast(G)) = D(G) = 1

Osservazione. Floding è inefficiente in termini di messaggi per grafi completi, mentre è efficiente per gli alberi.
Quindi funziona bene per grafi sparsi, che hanno pochi archi.

Idea. Da un grafo G posso sempre passare a T. Costruisco lo spanning Tree ed applico il flooding.
Occhio, stiamo aggiungendo una restrizione siccome per costruire lo ST devo conoscere la topologia del grafo.
In protocolli che usano molteplici volte il brodcast, il costo di costruire ST viene ammortizzato.

WAKE-UP PROBLEM.
Quando in un sistema distribuito un protocollo deve iniziare, serve che tutte le entità siano sveglie.
Parto da una situazione in cui alcune entità sono attive, mentre altre dormienit. Come faccio a svegliare le entità dormienti?

Idea: ogni entità sveglia manda un segnale di wakeup in flooding.

State S = {ASLEEP, AWAKE}
Sinit = {ASLEEP}
Sterm = {AWAKE}

ASLEEP
spontaneously
  send(W) to N(x)
  become(AWAKE)
receiving(W)
  send(W) to N(x) - {sender}
  become(AWAKE)

Costo messaggi.
1 init -> come flooding. Message(Wakeup(G)) = 2m - n + 1
Tutti init -> tutti mandano e si fermano. Message(Wakeup(G)) = 2m. Ogni link vede 2 messaggi, corrispondenti a quelli inviati dai due capi dormienti.
k init -> nel mezzo. Message(Wakeup(G)) = 2m - n + k

Costo temporale. Il caso peggiore è quando ho un solo AWAKE. In quel caso il tempo coincide con quello del flooding. O(n).