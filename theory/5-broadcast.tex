\section{Broadcast}
\defbox{
  \textbf{Broadcast.} Problema in cui una entità vuole inviare una informazione $I$ a tutte le altre
  entità della rete.

  Restrizioni: iniziatore unico (per definizione del problema), rete connessa
  (altrimenti alcuni nodi resterebbero esclusi), total reliability, link bidirezionali
}

\subsection{Flooding}
\begin{algorithm}[H]
\caption{Naive Broadcasting Algorithm}
\begin{algorithmic}[1]
\State S = \{INITIATOR, SLEEPING, DONE\}
\State
\State INITIATOR
\State spontaneously:
\State   \hskip1.0em send(I) to N(x)
\State   \hskip1.0em become(DONE)  \Comment{Transitiamo allo stato DONE}
\State
\State on receiving(I):
\State   \hskip1.0em nil. \Comment{In futuro ometteremo le azioni nil, se non specificate si evitano}
\State
\State SLEEPING
\State on receiving(I):
\State   \hskip1.0em send(I) to N(x) - \{sender\}  \Comment{Sender è il nodo da cui ho ricevuto il messaggio}
\State   \hskip1.0em become(DONE)  \Comment{Transitiamo allo stato DONE}
\State
\State DONE \Comment{No actions}
\end{algorithmic}
\end{algorithm}

\obsbox{Lo stato DONE costituisce una terminazione locale, non esiste lo stato di terminazione globale, sappiamo solo che l'algoritmo prima o poi terminerà.}
\obsbox{Nessuna entità conosce quando l'intero processo termina, problema che prende il nome di \textbf{termination detection problem}.}

Correttezza? assicurata dalle restrizioni di connessione totale e affidabilità totale.
In un grafo connesso troveremo sempre un cammino dall'inizializzatore ad ogni altro nodo.

Terminazione? Oltre a quanto scritto sopra, un'entità entra nello stato DONE dopo aver ricevuto (e inviato) il messaggio.
Combinando le due osservazioni, tutte le entità arriveranno ad essere nello stato DONE.

\subsubsection{Analisi dei Costi}
Convenzione: $n$ numero di nodi, $m$ numero di link.

Tip: per calcolare il costo temporale cerca relazioni tra quello che vuoi contare e quantità già note.
Da tenere in considerazione sono il numero di messaggi per arco, il numero di archi, ecc.

Analizziamo il \textbf{numero di messaggi}.

Costo se non ci fosse l'ottimizzazione \texttt{N(x) - \{sender\}}?
su ogni arco incidono due nodi, ogni nodo trasmette $I$ una sola volta; l'arco vede al massimo 2 messaggi:
$$ \text{Num of messages per link} \leq 2 \Rightarrow \text{Messages}(\text{Flooding}) \leq 2m \in O(m) $$

Con l'ottimizzazione, dato un iniziatore $s$, il costo è:
$$
|N(s)| + \sum_{x \neq s} (|N(x)| - 1) =
\underbrace{\sum_x |N(x)|}_\text{Somma dei gradi dei nodi di un grafo}
- \sum_{x \neq s} 1 = 2m - (n-1)
$$

Analizziamo ora l'\textbf{ideal time complexity} (in una unità di tempo ogni vicino riceve un messaggio).
Come sempre siamo interessati al \textbf{worst case}: il caso peggiore
tra tutti i possibili iniziatori e tutte le possibili esecuzioni.

\defbox{ Distanza tra due nodi $d(a, b)$. Numero minimo di archi tra tutti i percorsi che esistono tra $a$ e $b$. }
\defbox{ Raggio, o eccentricità, $r(a)$. Massima distanza di un nodo $a$ da qualsiasi altra entità. }
\defbox{ Diametro di un grafo $D(G)$. Massima eccentricità tra tutti i nodi di G. }

Il primo messaggio è inviato dall'iniziatore e deve raggiungere tutte le entità.
L'ideal time speso per andare da init.\ a tutti gli altri nodi è:
$$r(\text{init}) = \max_y{d(\text{init}, y)} \forall y \in E$$

Nel caso generale non conosciamo quale sia l'iniziatore.
Il caso peggiore è individuato dal peggiore iniziatore per ogni possibile esecuzione.
$$\max_{(x, y) \in E x E}{d(x, y)} = \max_{x \in E}{r(x)} = D(G)$$

Abbiamo che:
$$ \text{Time}(\text{Flooding}(G)) \leq D(G) \leq n-1 \in O(n) $$

Conseguenza: la topologia peggiore è quella in cui la rete è una catena (nodi srotolati e messi in fila).

In caso di casual time complexity il costo peggiore rimane n-1.
Anche se un grafo non è una catena, la propagazione dei messaggi sugli altri cammini potrebbe essere così lenta che la propagazione più
veloce è quella lungo il diametro, richiedendo così il numero di messaggi specificato.
Se sugli altri percorsi l'informazione fluisce più velocemente, raggiungeremo convergenza prima che sia necessaria la propagazione
sul diametro del grafo.

Si possono usare meno di n-1 time units? no, altrimenti salteremmo qualche nodo sul diametro del grafo.
Possiamo provarlo calcolato un lower bound per il \textit{problema}:
$$ \text{Time}(\text{Broadcast}(G)) \geq \max_{(x, y)}{d(x, y)} = D(G)$$


Ma\dots possiamo fare meglio in termini di numero di \textit{messaggi}?\\
Intuzione: Dalla formulazione del problema, ogni entità deve conoscere $I$.
Escluso l'inizializzatore, rimangono $n-1$ entità che non conoscono $I$.
Almeno $n-1$ messaggi devono essere mandati:
$$\text{Messages}(\text{Broadcast}(G)) \geq n-1 \in \Omega(n)$$

Considerazione: ogni messaggio deve passare almeno una volta su ogni arco, altrimenti alcune porzioni del grafo potrebbero
non ricevere I. Richiedere se l'altro nodo non ha il messaggio prima di mandarlo farebbe comunque spendere più di un
messaggio per arco.

Possiamo migliorare (rendere più tight, quindi alzare) la stima del LB per il problema:
$$ \text{Messages}(\text{Broadcast}(G)) \geq m \in \Omega(m) $$

Ricorda, stiamo cercando di chiudere il gap tra LB del \textit{problema} e costo dell'\textit{algoritmo} di flooding.
\begin{align*}
\text{Messages}(\text{Broadcast}(G)) >= m\\
\text{Messages}(\text{Flooding}(G)) = 2m - n + 1 (dalla scorsa lezione)\\
\text{Messages}(\text{Flooding}(G)) >= \text{Messages}(\text{Broadcast}(G))
\end{align*}

Possiamo fare di meglio? Il gap che cerchiamo di chiudere è "grande": $2m - n + 1 - m = m - n + 1$.
Dobbiamo sostanzialmente fare sparire il fattore 2.

Se applichiamo restrizioni al problema, si può fare di meglio.
Al posto che cambiare l'algoritmo, cerchiamo istanze specifiche per cui possiamo risolvere il problema con il costo
specificato dal lower bound.

Restrizione 1: consideriamo un albero.\\
Assumendo che $G$ è un albero $T$ abbiamo $m = n-1$ (ogni nodo ha un arco padre a parte la radice).

$$ \text{Messages}(\text{Flooding}(T)) = 2m - n - 1 = 2(n-1) - n - 1 = n - 1 = m $$

Gli algoritmi di flooding hanno complessità ottimale, in termini di messaggi inviati, per gli alberi.
Nota che le entità non necessitano di sapere che si trovano su un albero.

Restrizione 2: grafo completo. A.k.a. ogni nodo è connesso con tutti gli altri.\\
Nei grafi completi: $m = \frac{n(n-1)}{2}$. Ripassa matematica combinatoria o usa un ragionamento intuitivo: ogni nodo è
connesso ad altri $n-1$; esistono $n$ nodi; moltiplicando questi due numeri otteniamo il numero di archi diretti,
ma nel nostro caso non hanno direzione, quindi dobbiamo dimezzare il risultato. Il risultato è:
$$ \text{Messages}(\text{Flooding}(G_\text{completo})) \in \theta(n^2) $$

Dato che il grafo è completo, basta che l'iniziatore mandi a tutti i suoi vicini un messaggio (algoritmo che chiamiamo
SimpleBroadcast):
\begin{align*}
\text{Messages}(\text{SimpleBroadcast}(G)) = n-1\\
\text{Time}(\text{SimpleBroadcast}(G)) = D(G) = 1
\end{align*}

\obsbox{
  Il flooding è inefficiente, in termini di messaggi inviati, per grafi completi, mentre è efficiente per gli alberi.
  Quindi funziona bene per grafi sparsi, che hanno pochi archi.
}

Idea: da un grafo $G$ posso sempre passare ad un albero di copertura $T$; costruisco lo spanning tree ed applico il flooding.
Attenzione, stiamo aggiungendo una restrizione siccome per costruire lo ST devo conoscere la topologia del grafo.
Se non voglio aggiungere questa restrizione, devo usare un algoritmo distribuito che costruisca ST, potrebbe essere costoso.
In protocolli che usano molteplici volte il brodcast, il costo di costruire ST viene ammortizzato

\subsection{Wake-up Problem}
Quando in un sistema distribuito un protocollo deve iniziare, serve che tutte le entità siano sveglie.
Parto da una situazione in cui alcune entità sono attive, mentre altre dormienti. Come faccio a svegliare le entità dormienti?

Idea: ogni entità sveglia manda un segnale di wake-up in flooding.

\begin{algorithm}[H]
\caption{Wake-up Flooding}
\begin{algorithmic}[1]
  \State State $S$ = \{ASLEEP, AWAKE\}
  \State $S_\text{init}$ = \{ASLEEP\}
  \State $S_\text{term}$ = \{AWAKE\}
  \State
  \State ASLEEP
  \State spontaneously:
  \State   \hskip1.0em send(W) to N(x)
  \State   \hskip1.0em become(AWAKE)
  \State receiving(W)
  \State   \hskip1.0em send(W) to N(x) - \{sender\}
  \State   \hskip1.0em become(AWAKE)
\end{algorithmic}
\end{algorithm}

Analizziamo il numero di messaggi, correlandolo al numero di iniziatori:
\begin{itemize}
  \item 1 init: come il flooding $\text{Message}(\text{Wakeup}(G)) = 2m - n + 1$
  \item tutti init: tutti mandano e si fermano, quindi $\text{Message}(\text{Wakeup}(G)) = 2m$. Ogni link vede 2 messaggi, corrispondenti a quelli inviati dai due capi dormienti.
  \item k init: numero di messaggi compreso tra i due precedenti, ovvero $\text{Message}(\text{Wakeup}(G)) = 2m - n + k$
\end{itemize}

Costo temporale: il caso peggiore è quando ho un solo AWAKE; in quel caso il tempo coincide con quello del flooding, ovvero $O(n)$.