\section{Algoritmi di Approssimazione}
\subsection{Fattore di Approssimazione}
Def. Fattore di di approssimazione $\alpha \geq 1$.
$\forall \text{istanza del problema} \frac{cost_approx(I)}{cost_opt(I)} \leq \alpha$

I.e., la soluzione approssimata ricade nella finestra delimitata dal costo approssimato e alpha volte il costo approssimato.
Abbiamo così determinato un upper bound al costo della soluzione approssimata.

\subsection{Algoritmo di Christofides per TSP}
Esiste un risultato secondo cui il fattore di approssimazione per un algoritmo di approssimazione di TSP non è costante,
ammesso che $P \neq NP$. Un fattore di approssimazione variabile, dipendente dal numero di veritici, è sostanzialmente inutile.
Questo è vero per istanze generiche del problema; ammettendo una restrizione del problema originale
possiamo trovare algoritmi con fattori di approssimazione costanti.

Algoritmo di Christofides per TSP con proprietà triangolare sulla funzione di costo.
Trova una soluzione approssimata.
Secondo la proprità triangolare: $l_1 + l_2 \geq l_3$. Applicata ai costi ci indica che è più conveniente passare per $l_3$.

Ripassa: Prim e Kruskals

1. Costruisco T* minimum spanning tree sul grafo originale con Kruskal o Prim.
2. Considero i nodi di T* di grado dispari (numero dispari di archi connessi al nodo). Cerco il \textit{perfect matching} di costo minimo M* **nota
3. Cerco il ciclo euleriano E su $T* \cup M*$
4. Da E costruisco il ciclo hamiltoniano H partendo da E ed eliminando tutti i nodi visitati già visitati


**nota
Dato un grafo G = (V, E), il matching $M \in E$ è l'insieme di archi che coprono tutti i vertici del grafo, in modo tale che ogni coppia
di archi non condivida nessun nodo.
Prendiamo il perfect matching di costo minimo $M* \in E$.

Problemi:
1. Al passo 2, non sempre esiste un cammino euleriano su un grafo. Necessitiamo di tutti i nodi di grado pari.
Assicurato per costruzione: ad ogni nodo di grado dispari abbiamo aggiunto un nodo, rendendolo di grado pari.
2. Il matching al passo 2 richiede un numero di nodi pari, altrimenti uno rimane fuori. **assocurato

**Assicurato
Somma dei gradi dei nodi di un grafo: S = 2 |E|. Ogni arco incide su due nodi.
La somma dei nodi di grado pari P è pari, dato che rimane un fattore due.
La somma dei nodi di grado dispari continua ad essere pari: D = S - P, posso raccogliere un due.
Siccome i numeri che compongono la somma sono dispari, il loro numero deve essere pari.

\subsection{Analisi dei Costi}
Definiamo H soluzione approssimata, H* soluzione ottimale.

Dato T* MST su G, rimuovendo un arco dal H* ottengo un albero T di costo minore rispetto a H*, dato che ho eliminato un arco:
cost(H*) >= cost(T)
Chiamiamo T 'cammino'.

Il costo del MST è sicramente minore di T per costruzione: cost(H*) >= cost(T) >= cost(T*)

Dato il grafo originale G, scelgo i nodi di grado dispari (numero di nodi pari) che appartengono a H*. Chiamo il grafo indotto da questi nodi $\Gamma$.
Il costo di questo grafo costa meno dalla disuguaglianza triangolare.
Dato il grafo $\Gamma$ è sufficiente metà grafo per ottenere un matching. Entrambi i matching saranno di costo superiore al perfect matching (per def quello di costo minimo). 
cost(H*) >= cost($\Gamma$) = cost(M1) + cost(M2) >= 2 cost(M*).

Il ciclo euleriano passa una e una sola volta per gli archi di T* e M*: cost(E) = cost(T*) + cost(M*).

Il costo di H, soluzione approssimata, è inferiore o uguale al costo del ciclo euleriano, dato che da E eliminiamo i nodi già visitati;
inoltre, per proprietà triangolare, l'arco diretto (shortcut) è sempre più vantaggioso del giro lungo.
I costi di T* e M* possono essere maggiorati dalle disequazioni sopra.
cost(H) <= cost(E) = cost(T*) + cost(M*) <= cost(H*) + cost(H*)/2 = 3/2 cost(H*)

Per questo algo quindi $\alpha = \frac{3}{2}$.

Come capire se la finestra definita da alpha è tight? possiamo essere sicuri che la finestra sia la minima possibile trovando
almeno un caso in cui il costo coincide con l'estremo superiore della finestra 3/2 cost(H*).

Basta trovare un'istanza del problema con costo pari all'UB. Tuttavia, questa specifica istanza potrebbe essere risolta
differentemente per ovviare al costo. Quindi, è bene trovare una famiglia di grafi che racchiuda al suo interno un numero infinito di
istanze.

La struttura della famiglia di grafi che consideriamo comprende un numero dispari di nodi collegati, da archi di costo 1, nel modo seguente TODO

Il MST T* è quello che percorre lo zig zag interno del grafo: cost(T*) = n-1. Come prima è un grafo degenere, ovvero un cammino.

Si scelgono i nodi di grado dispari per costruire il perfect matching. Gli unici nodi di grado dispari sono le estremità.
Si aggiunge un arco che unisce i due estremi.
Il costo del perfect matching M* è il costo di questo arco: cost(M*) = (n-1)/2, corrispondente al numero di archi
della parte sud del grafo.

Il costo di E è la somma dei due: cost(E) = cost(T*) + cost(M*) 3/2 (n-1) = cost(H).
Il costo hamiltoniano costa uguale perchè non percorriamo nessun nodo più di una volta.

È possibile di mostrare che il costo del ciclo hamiltoniano ottimo è quello che visita tutti i nodi del grafo esternamente.
Questo costo è uguale a n.

Dunque: $\alpha = \frac{3 (n-1)}{2n} \rightarrow \frac{3}{2}$ per $n \rightarrow \infty$.
Abbiamo così dimostrato che l'UB è tight.

\subsection{Vetex Cover}
Def. Vertex Cover $V' \cup V$ tale che tutti gli archi siano copert: $\forall (u, v) \in E | u \in V' or v \in V$.

Def. Vertex Cover di costo minimo: vertex cover di minima cardialità (minimo numero di nodi possibili).

Input: G = (V, E) non diretto (no vincoli su completezza)
Output: vertex cover di costo minimo.

Esempio: coprire con il numero minimo di telecamere tutte le strade di un grafo.

Una soluzione greedy potrebbe essere quella di scegliere un nodo alla volta, eliminando man mano i vertici coperti,
finchè non si arriva alla copertura degli archi completa.

Un diagramma a stella dimostra che la soluzione approssimata si discosta molto da quella ottima.
cost(OPT) = 1
cost(APPROX) = m-1

\subsubsection{Greedy Vertex Cover}
Un'alternativa greedy consiste nel selezionare man mano gli archi, inserendo i vertici su cui incidono nel VC.

Snippet: greedy VC(G)
C = set()
while E not empty:
  scegli (u, v) in E a caso
  C.add(u, v)
  elimina gli archi incidenti in u e v
return C

Costo polinomiale: alla peggio visito tutti gli archi. Terminazione assicurata dal fatto che ad ogni iterazione almeno l'arco (u, v)
viene eliminato.

Il VC ritornato è sempre di cardinalità pari, dato che per ogni arco vengono aggiunti due nodi e tutti i nodi incidenti venogno eliminati.

Definito E' in E insieme degli archi selezionati durante l'esecuzione, sappiamo che |C| = 2 |E'|.
Infatti, per ogni arco selezionato inseriamo due nodi.

Dati E' archi disgiunti, servono almeno C nodi. |C| = 2 |E'|. Inoltre |E'| <= |C*|, dove C* è la soluzione ottima.
Per proprietà transitiva |C| <= 2|C*|, quindi alpha 2.

Si può dimostrare che l'UB è tight con la famiglia di grafi a stella.
Il costo ottimo cost(OPT) = 1, mentre cost(APPROX) = 2, portando a un coefficiente di 2.

\subsubsection{ILP Vertex Cover}
Possiamo migliorare il coefficiente di approssimazione usando la programmazione lineare intera.

Usiamo la tecnica generica di relax-round.

1) Formuliamo il problema secondo il framework della programmazione lineare intera:
$$
\forall v \in V : x_v = 0 se v \notin VC, 1 otherwise
min \sum_{v \in V} x_v
x_v + x_u \geq 1 \forall (u, v) \in E
x_v \in \{0, 1\}  vincolo di interezza
$$

Aka:
 - per ogni vertice associamo una variabile booleana che rapprsenta se il vertice viene scelto come appartenente al vertex cover.
 (da qui l'interezza)
 - vogliamo scegliere il numero minimo di vertici.
 - almeno uno tra i due vertici incidenti sullo stesso arco deve essere scelto.

2) Posso dare questa formulazione in pasto ad un solver? no, anche la ILP è un problema NP-hard

Per questo motivo rilassiamo il vincolo di interezza per rendre la risoluzione più facile: il nuovo problema di programmazione lineare
(linear programming --- LP) ammette $x_v \in [0, 1]$.

3) Passiamo alla fase di rounding per decidere se scegliere il vertice.
Dato il risultato ottimo di LP $x_v* \in [0, 1]$ vogliamo trasformarlo in $\hat{x_v} \in \{0, 1\}$.

$$
\hat{x_v} = 0 if x_v* \lt 0.5, 1 if x_v* \geq 0.5
$$

Scegliamo 1 se il $x_v*$ è 0.5 perchè, se scegliessimo 0, la soluzione potrebbe non essere un cover.
E.g., quando due vertici connessi da un arco hanno costo 0.5: in questo caso il vincolo di somma maggiore o uguale a 1 è rispettato,
ma se l'arrotondamento di 0.5 venisse fatto a 0, nessuno dei due verrebbe preso.

Da una prospettiva diversa: negli algoritmi di approssimazione scendiamo a compromessi sul costo del'algoritmo, non sulla correttezza
della soluzione (in questo caso il fatto che il VC debba essere completo).

4) Il VC approssimato è $\{ v \in V | \hat{x_v} = 1 \}$. Sicuramente è un VC in quanto, essendo partiti dalla soluzione 'star' soggetta
al vincolo di somma maggiore di 1, sicuramente per ogni arco sceglieremo almeno un vertice incidente. La somma di due numeri non può
essere almeno 1 con entrambi i valori sotto a 0.5.

Analisi di costo. Dato lo spazio delle soluzioni LP, le soluzioni ILP sono un suo sottoinsieme. TODO diagramma eulero venn
La soluzione, se si trova nel sottoinsieme ILP, allora è ottima per entrambi; le soluzioni ottime coincidono.
Se la soluzione ottima si trova in LP, ma non il ILP, allora il suo costo sarà minore siccome la formulazione ha vincoli più lassi della
controparte ILP.

Poniamo $C_{ILP} = \sum_{v \in V} x_v$ e $C_{LP} = \sum_{v \in V} x_v^*$.
Per quanto appena scritto stanno nella relazione $C_{ILP} \geq C_{LP}$ (sempre valido per rilassamenti in LP).
Nota che ILP coincide con l'ottimo.

Ora cerchiamo di mettere in relazione LP (star) e APPROX (hat).
Cerchiamo una maggiorazione: $\hat{x_v} \leq 2 x_v^* \forall v \in V$. Verifica: 
 - se $\hat{x_v} = 0 \rightarrow x_v^* compreso tra 0 e 1/2 escluso$
 - se $\hat{x_v} = 1 \rightarrow x_v^* compreso tra 1/2 e 1$

Passiamo alla sommatoria mantenendo la relazione: $\sum_{v \in V} \hat{x_v} \leq 2 \sum_{v \in V} x_v^*$.
Mettiamo insieme la catena di disequazioni: $C_APPROX / C_OTT  \leq 2$.

Analisi tight? sì, dimostrabile con l'esempio di un grafo ad anello con numero pari di nodi.
APPROX = n, OPT = n/2 (numero pari di nodi per poter dividere).

Vedi: materiale extra su branch-and-bound

