\section{Teoria della Complessità}
\subsection{Problemi Decisionali}
La trattazione formale più agevole per trattare alcuni problemi è quella in cui si considera la variante \textbf{decisionale} del problema.\\
Ad esempio, il problema dello shortest path ammette la versione di ottimizzazione, in cui dato un grafo e due vertici ci si chiede la
lunghezza del cammino minimo tra i due vertici, e la versione decisionale in cui si aggiunge all'input un valore $k$ e ci si chiede se esista un
cammino migliore (lunghezza minore o uguale) di $k$.

\subsection{Teoria della Complessità}
\defbox{
  \textbf{Problemi P}: insieme dei problemi decisionali risolvibili con un algoritmo di costo temporale polinomiale nella dimensione dell'input.
}

Trovare un algoritmo polinomiale per il problema è sufficiente per dimostrare che il problema appartiene a P.

Il problema del \textit{ciclo emiltoniano} è un problema per il quale \underline{non esiste} un algoritmo noto di costo polinomiale, ma per il quale la
\textbf{verifica} di una soluzione (ad esempio sotto forma di permutazione dei nodi) richiede un \textbf{tempo polinomiale} (quindi è efficiente).

\defbox{
  \textbf{Certificato per una istanza positiva} $i$ del problema $\Pi$: sequenza di caratteri aggiuntiva (rispetto all'output), di dimensione al
  massimo polinomiale nella dimensione dell'input, che contiene l'evidenza che $i$ sia una istanza positiva (ovvero per cui l'algoritmo risolutore
  ritorna "\textit{yes}") per $\Pi$.
}

\defbox{
  \textbf{Algoritmo verificatore}: algoritmo decisionale che prende un input $i \in \mathbb{I}$, istanza di un problema decisionale $\Pi$, e una sequenza di
  caratteri $C_i$; tale algoritmo restitusce ``\textit{yes}'' se $i$ è un'istanza positiva per $\Pi$, ``\textit{no}'' altrimenti.}

Se un algoritmo verificatore restituisce ``\textit{yes}'', allora $C_i$ è un certificato per $i$; se la risposta è ``\textit{no}'',
$i$ non è un'istanza positiva, oppure $C_i$ non è un certificato per $i$;
ma, in questo secondo caso, potrebbe comunque esistere un certificato valido per l'istanza.

\defbox{
  \textbf{Verificabilità}. Un problema è verificabile se:
  \begin{itemize}
    \item per ogni istanza positiva $i \in \mathbb{I}$ di $\Pi$, esiste un certificato $C_i$ (polinomiale nell'input)
    \item esiste un algoritmo verificatore $A$ che risponde ``\textit{yes}'' per ogni coppia $(i, C_i)$ tale che $i$ è istanza positiva di $\Pi$
  \end{itemize}
}

\defbox{Problemi Non-deterministic Polynomial-time (NP): classe di problemi decisionali che possono essere verificati con un algoritmo verificatore
di costo temporale polinomiale.}

\theobox{
$\mathit{P} \subseteq  \mathit{NP}$.

\proofbox{
Dato un problema $\Pi \in P$, esiste un algoritmo $A$ di costo polinomiale che può essere utilizzato come verificatore, passandogli come
certificato la stringa vuota, e che coincide proprio con l'algoritmo risolutore: l'algoritmo verificatore invoca l'algoritmo risolutore
$A$ per $\Pi$ su un'istanza del problema e restituisce il risultato. Se l'istanza è positiva il risultato è "\textit{yes}", altrimenti "\textit{no}".
}}

A questo punto ci chiediamo la seguente cosa: i problemi P sono solamente un \textbf{caso particolare} degli NP o le due classi \textbf{coincidono} ($P = \mathit{NP}$)?\\
Dato che ci sono problemi NP che \textbf{sembrano più difficili} di problemi P, è ragionevole pensare che tali problemi risiedano in $\mathit{NP} \setminus P$
(classe dei problemi \textbf{NP-completi}). Conseguenza di questo sarebbe che le due classi non coincidono.

Cerchiamo ora di caratterizzare i problemi in NP che sembrano più difficili dei problemi P.
Introduciamo l'operatore $\leq_p$. Dati due problemi $A$ e $B$, $A \leq_p B$ significa che $B$ non è più facile di $A$ o, al dalla prospettiva
opposta, che $A$ non è più difficile di $B$.

\defbox{
  \textbf{Riduzione di Karp}: dati due problemi decisionali $A$ e $B$ tali che $A \leq_p B$, $A$ è riconducibile in tempo
  polinomiale a $B$ se ogni istanza di $A$ può essere \textbf{trasformata} in \textbf{tempo polinomiale} in un'istanza di $B$,
  mantenendo la natura dell'istanza: se era positiva per $A$, deve essere positiva anche per $B$; se era negativa per $B$,
  deve rimanerlo anche per $B$.
}

Nota che siccome un algoritmo risolutivo per $B$ può essere usato per risolvere $A$, è naturale che $A \leq_p B$, ovvero che l'algoritmo risolutivo
più "potente" riesca a risolvere anche un problema più facile.\\
Osservazioni su $A \leq_p B$:
\begin{itemize}
  \item se $B \in P \Rightarrow A \in P$. L'algoritmo polinomiale per $B$ può essere adattato ad $A$ mediante la riduzione
  \item se $A \notin P \Rightarrow B \notin P$. Se $B \in P$ avremmo un algoritmo polinomiale anche per $A$, dall'oss. sopra
  \item se $A \in P$ non deduciamo niente su $B$
  \item se $B \notin P$ non deduciamo niente su $A$
  \item se $B \leq_p A \Rightarrow A \equiv B$
  \item se $B \leq_p C \Rightarrow A \leq_p C$ per transitività. Ci serviranno due riduzioni polinomiali al posto di una per adattare $A$ a $C$
\end{itemize}

\defbox{
  Un problema $A$ è \textbf{NP-completo} se:
  \begin{enumerate}
    \item $A \in \mathit{NP}$. Ovvero è in $\mathit{NP}$.
    \item $\forall B \in \mathit{NP} : B \leq_p A$. Ovvero $A$ è difficile almeno quanto il più difficile dei problemi in NP.
    Implica che ogni problema in $\mathit{NP}$ può essere ridotto al problema $A$ in tempo polinomiale tramite una riduzione di Karp.
  \end{enumerate}
}

La conseguenza del punto 2 è la seguente: se riuscissimo a trovare una soluzione polinomiale ad un problema NP-completo (nel caso sopra $A$),
saremmo in grado di risolvere qualsiasi altro problema NP in tempo polinomiale, semplicemente aggiungendo a monte una riduzione di Karp.
Ciò implicherebbe $\mathit{P} = \mathit{NP}$.

Allo stesso modo, se si riuscisse a dimostrare che, anche per un solo problema NP-completo, non esistono algoritmi di costo polinomiale,
allora vorrebbe dire che $\mathit{P} \neq \mathit{NP}$.

I teoremi di Cook e Levin hanno dimostrato l'esistenza del primo problema NP-completo: il problema della \textbf{Satisfability} (SAT).
Un problema decisionale in cui viene data in input una CNF (Conjunctive Normal Form) e ci si chiede se esista un assegnamento delle variabili
che renda vera la formula. E.g.: $(a \vee \bar{b} \vee c) \wedge (\bar{a} \vee c) \rightarrow \text{Y/N}$.

Esiste un'altra classe di problemi, i problemi \textbf{NP-hard}, per i quali anche la verifica della soluzione non è scontata, come il problema del
commesso viaggiatore (Traveling Salesman Problem --- TSP).

\defbox{
  Un problema $A$ è \textbf{NP-hard} se: $$\forall B \in \mathit{NP} : B \leq_p A$$
  Rispetto alla definizione di prima stiamo rimuovendo il vincolo che esso appartenga a NP.
  Ovvero, $A$ è NP-hard se è difficile almeno quanto il più difficile dei problemi NP.
}

Due possibili scenari: se $\mathit{P} = \mathit{NP}$, questo insieme è totalmente contenuto in NP-hard, altrimenti, se $\mathit{P} \neq \mathit{NP}$,
NP e NP-hard sono due insiemi che, intersecandosi, danno vita all'insieme di problemi NP-completi. 

Possibili soluzioni ai problemi NP hard:
\begin{itemize}
  \item applicarli a istanze piccole
  \item utilizzare euristiche
  \item utilizzare versioni parallele o distribuite
  \item utilizzare algoritmi di approssimazione
\end{itemize}

Le euristiche non ci danno garanzie sull'ottimalità della soluzione, mentre gli algoritmi di approssimazione ci danno garanzie
sull'upper-bound della soluzione, e.g. la soluzione trovata ha costo al più doppio rispetto all'ottimo.
Un algoritmo di approssimazione trova una soluzione ammissibile, potenzialmente subottimale, con garanzie di discostamento dal costo della
soluzione ottima.

\proofbox{
  \textbf{TSP è un problema NP-hard}.\\
  Come lo dimostriamo? una soluzione del TSP ci consente di risolvere un altro problema NP-completo, il problema del ciclo hamiltoniano (HC)
  nella sua forma decisionale, attraverso una riduzione polinomiale.

  Piano: prendiamo un'istanza del problema NP-completo HC, corventiamola in un'istanza di TSP in tempo polinomiale,
  risolviamo TSP, trasformiamo infine l'output di TSP in una risposta decisionale del problema originale.

  \begin{verbatim}
  istanza HC --> | conversione polinomiale | -> | algo TSP | -> | conversione polinomiale | -> Y/N
  \end{verbatim}

  Input HC: $G = (V, E)$ non diretto.\\
  Ouput HC: esiste un ciclo hamiltoniano (ciclo che attraversi tutti i nodi tornando all'origine)?
  
  Input TSP: $G = (V, E)$ non diretto e completo e una funzione di costo $c: E \rightarrow R^+$ che mappa ogni arco ad un costo reale.\\
  Output TSP: ciclo hamiltoniano di costo minimo.
  
  CONVERSIONE INPUT\\
  Mancano due cose: costi e potenzialmente alcuni archi.
  La fase di conversione aggiunge archi per renderlo un grafo completo.
  Gli archi aggiunti $\tilde{E}$ hanno costo 1, mentre quelli originali $E$ hanno costo 0;
  forziamo il risolutore a schivare gli archi appena aggiunti (più costosi di quelli originali).

  COVERSIONE OUTPUT\\
  Dato un ciclo, possiamo calcolare il costo K del ciclo: $0 \leq K \leq \min(|V|, |\tilde{E}|)$
  L'output è Y se $K=0$, altrimenti N.

  Conclusione: abbiamo così dimostrato che, trovando una soluzione ad HC (problema NP-completo) tramite TSP,
  il problema TSP è NP-hard (nota come non abbiamo fatto assunzioni sull'algoritmo verificatore).
}